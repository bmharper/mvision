#include "pch.h" 
#include "Codecs.h"
#include "../Common.h"
#include "../image/image.h"
#include "../util/Mem.h"

#ifdef SX_INTEL_MEDIA_SDK

namespace sx
{

static int RoundUp(int v, int multiple)
{
	return ((v + multiple - 1) / multiple) * multiple;
}

H264Decoder::~H264Decoder()
{
}

IntelH264Decoder::IntelH264Decoder()
{
}

IntelH264Decoder::~IntelH264Decoder()
{
	MFXClose(Session);
	Session = nullptr;
}

bool IntelH264Decoder::Init()
{
	mfxVersion ver;
	ver.Major = 1;
	ver.Minor = 0;
	//auto err = MFXInit(MFX_IMPL_HARDWARE_ANY, &ver, &Session);
	//auto err = MFXInit(MFX_IMPL_SOFTWARE, &ver, &Session);
	auto err = MFXInit(MFX_IMPL_AUTO_ANY, &ver, &Session);
	if (err != MFX_ERR_NONE)
		return false;

	mfxIMPL impl;
	MFXQueryIMPL(Session, &impl);
	return true;
}

size_t IntelH264Decoder::AddData(const void* buf, size_t bufSize)
{
	std::lock_guard<std::mutex> lock(BufLock);
	Buf.Push(buf, bufSize);
	return bufSize;
}

size_t IntelH264Decoder::Decode(const void* buf, size_t bufSize)
{
	if (Session == nullptr)
		return 0;

	size_t consumed = 0;
	if (!IsInitialized)
	{
		consumed = Reset(buf, bufSize);
		if (!IsInitialized)
			return consumed;
	}

	bool ateData = true;
	while (ateData)
	{
		ateData = false;
		mfxFrameSurface1* surf = nullptr;
		mfxSyncPoint sync = nullptr;
		mfxBitstream bs = { 0 };
		bs.Data = (uint8_t*) buf + consumed;
		bs.DataLength = bufSize - consumed;
		bs.MaxLength = bufSize - consumed;
		mfxStatus err = MFXVideoDECODE_DecodeFrameAsync(Session, &bs, &WorkSurface, &surf, &sync);
		consumed += bs.DataOffset;
		if (bs.DataOffset != 0)
			ateData = true;
		if (err == MFX_ERR_NONE && surf != nullptr && surf->Info.FourCC == MFX_FOURCC_NV12)
		{
			if (surf->Info.FourCC == MFX_FOURCC_NV12)
			{
				Image* img = new Image();
				if (!img->Alloc(ImgFmt::RGBA8u, VideoParam.mfx.FrameInfo.Width, VideoParam.mfx.FrameInfo.Height))
					SXDIE_OOM();
				libyuv::NV12ToARGB(surf->Data.Y, surf->Data.PitchLow, surf->Data.UV, surf->Data.PitchLow, (uint8*) img->Scan0, img->Stride, img->Width, img->Height);
				img->FixBGRA_to_RGBA();
				Frames.push_back(img);
			}
			else
			{
				Log()->Error("Unexpected FourCC from MFXVideoDECODE_DecodeFrameAsync: %x", surf->Info.FourCC);
			}
		}
	}

	return consumed;

	//Reset();
	/*
	mfxVideoParam vpar = { 0 };
	vpar.IOPattern = MFX_IOPATTERN_IN_SYSTEM_MEMORY | MFX_IOPATTERN_OUT_SYSTEM_MEMORY;
	vpar.mfx.CodecId = MFX_CODEC_AVC;
	vpar.vpp.Out.Width = 640;
	vpar.vpp.Out.Height = 480;
	vpar.vpp.Out.FourCC = MFX_FOURCC_RGB4;
	err = MFXVideoDECODE_Init(Session, &vpar);
	if (err != MFX_ERR_NONE)
	{
		return false;
	}
	return true;
	*/
}

Image* IntelH264Decoder::ReadFrame()
{
	ConsumeBuf();
	if (Frames.size() != 0)
	{
		auto f = Frames.back();
		Frames.pop_back();
		return f;
	}
	return nullptr;
}

int IntelH264Decoder::FramesInQueue()
{
	return (int) Frames.size();
}

void IntelH264Decoder::ConsumeBuf()
{
	// Steal the buffer
	ByteBuf stolenBuf;
	{
		std::lock_guard<std::mutex> lock(BufLock);
		std::swap(stolenBuf, Buf);
	}

	if (stolenBuf.Len == 0)
		return;

	size_t consumed = Decode(stolenBuf.Data, stolenBuf.Len);
	Log()->Debug("Consumed %d/%d", (int) consumed, (int) stolenBuf.Len);

	// Put back whatever didn't get consumed (expensive!)
	size_t remaining = stolenBuf.Len - consumed;
	if (remaining != 0)
	{
		std::lock_guard<std::mutex> lock(BufLock);
		if (consumed == 0 && stolenBuf.Len != 0)
			int abc = 123;
		Buf.Ensure(Buf.Len + remaining);
		memmove(Buf.Data + remaining, Buf.Data, Buf.Len);
		memcpy(Buf.Data, stolenBuf.Data + consumed, remaining);
		Buf.Len += remaining;
		//Log()->Debug("Buf: %d/%d", (int) Buf.Len, (int) Buf.Cap);
	}
}

void IntelH264Decoder::CreateWorkSurface(mfxFrameSurface1& surf)
{
	// Setup the "work surface". I don't understand why doesn't do this itself (malloc control is all I can assume).
	memset(&surf, 0, sizeof(surf));
	surf.Info = VideoParam.mfx.FrameInfo;
	surf.Info.FourCC = MFX_FOURCC_NV12; // IMSDK docs say NV12 is "Native Format" for IMSDK

	surf.Data.PitchLow = RoundUp(VideoParam.mfx.FrameInfo.Width, 64);
	surf.Data.Y = (mfxU8 *) AlignedAlloc(surf.Data.PitchLow * RoundUp(VideoParam.mfx.FrameInfo.Height, 64) * 3 / 2, 16);
	surf.Data.UV = surf.Data.Y + (surf.Data.PitchLow * RoundUp(VideoParam.mfx.FrameInfo.Height, 64));
}

size_t IntelH264Decoder::Reset(const void* buf, size_t bufSize)
//void IntelH264Decoder::Reset()
{
	mfxVideoParam par = { 0 };
	par.mfx.CodecId = MFX_CODEC_AVC;

	mfxBitstream bs = { 0 };
	bs.Data = (uint8_t*) buf;
	bs.DataOffset = 0;
	bs.DataLength = bufSize;
	bs.MaxLength = bufSize;
	bs.DecodeTimeStamp = MFX_TIMESTAMP_UNKNOWN;
	bs.TimeStamp = MFX_TIMESTAMP_UNKNOWN;
	//MakeBitstream(Buf, bs);

	//bs.Data = (uint8_t*) tpair;
	//bs.DataOffset = 0;
	//bs.DataLength = sizeof(tpair);
	//bs.MaxLength = sizeof(tpair);

	mfxStatus err = MFXVideoDECODE_DecodeHeader(Session, &bs, &par);

	if (err == MFX_ERR_NONE)
	{
		par.IOPattern = MFX_IOPATTERN_IN_SYSTEM_MEMORY | MFX_IOPATTERN_OUT_SYSTEM_MEMORY;
		err = MFXVideoDECODE_Init(Session, &par);
		if (err == MFX_ERR_NONE)
		{
			VideoParam = par;
			CreateWorkSurface(WorkSurface);
			IsInitialized = true;
		}
		else
		{
			Log()->Error("MFXVideoDECODE_Init failed: %d", err);
		}
	}

	return bs.DataOffset;
}

/*
void IntelH264Decoder::MakeBitstream(const ring::ByteBuf& rb, mfxBitstream& bs)
{
	memset(&bs, 0, sizeof(bs));

	size_t len = 0;
	rb.ReadPos(-1, (uint8_t*&) bs.Data, len);
	bs.DataLength = (uint32_t) len;
}

void IntelH264Decoder::AdjustFromBitstream(const mfxBitstream& bs, ring::ByteBuf& rb)
{
	rb.IncrementReadPos(bs.DataOffset);
}
*/

/*
// Known good stream (64x64 Lena image)
const uint8_t Lena64[] = 
{
	0x00, 0x00, 0x00, 0x01, 0x67, 0x64, 0x00, 0x0A, 0xAC, 0x72, 0x84, 0x44, 0x26, 0x84, 0x00, 0x00,
	0x03, 0x00, 0x04, 0x00, 0x00, 0x03, 0x00, 0xCA, 0x3C, 0x48, 0x96, 0x11, 0x80, 0x00, 0x00, 0x00,
	0x01, 0x68, 0xE8, 0x43, 0x8F, 0x13, 0x21, 0x30, 0x00, 0x00, 0x01, 0x65, 0x88, 0x81, 0x00, 0x05,
	0x4E, 0x7F, 0x87, 0xDF, 0x61, 0xA5, 0x8B, 0x95, 0xEE, 0xA4, 0xE9, 0x38, 0xB7, 0x6A, 0x30, 0x6A,
	0x71, 0xB9, 0x55, 0x60, 0x0B, 0x76, 0x2E, 0xB5, 0x0E, 0xE4, 0x80, 0x59, 0x27, 0xB8, 0x67, 0xA9,
	0x63, 0x37, 0x5E, 0x82, 0x20, 0x55, 0xFB, 0xE4, 0x6A, 0xE9, 0x37, 0x35, 0x72, 0xE2, 0x22, 0x91,
	0x9E, 0x4D, 0xFF, 0x60, 0x86, 0xCE, 0x7E, 0x42, 0xB7, 0x95, 0xCE, 0x2A, 0xE1, 0x26, 0xBE, 0x87,
	0x73, 0x84, 0x26, 0xBA, 0x16, 0x36, 0xF4, 0xE6, 0x9F, 0x17, 0xDA, 0xD8, 0x64, 0x75, 0x54, 0xB1,
	0xF3, 0x45, 0x0C, 0x0B, 0x3C, 0x74, 0xB3, 0x9D, 0xBC, 0xEB, 0x53, 0x73, 0x87, 0xC3, 0x0E, 0x62,
	0x47, 0x48, 0x62, 0xCA, 0x59, 0xEB, 0x86, 0x3F, 0x3A, 0xFA, 0x86, 0xB5, 0xBF, 0xA8, 0x6D, 0x06,
	0x16, 0x50, 0x82, 0xC4, 0xCE, 0x62, 0x9E, 0x4E, 0xE6, 0x4C, 0xC7, 0x30, 0x3E, 0xDE, 0xA1, 0x0B,
	0xD8, 0x83, 0x0B, 0xB6, 0xB8, 0x28, 0xBC, 0xA9, 0xEB, 0x77, 0x43, 0xFC, 0x7A, 0x17, 0x94, 0x85,
	0x21, 0xCA, 0x37, 0x6B, 0x30, 0x95, 0xB5, 0x46, 0x77, 0x30, 0x60, 0xB7, 0x12, 0xD6, 0x8C, 0xC5,
	0x54, 0x85, 0x29, 0xD8, 0x69, 0xA9, 0x6F, 0x12, 0x4E, 0x71, 0xDF, 0xE3, 0xE2, 0xB1, 0x6B, 0x6B,
	0xBF, 0x9F, 0xFB, 0x2E, 0x57, 0x30, 0xA9, 0x69, 0x76, 0xC4, 0x46, 0xA2, 0xDF, 0xFA, 0x91, 0xD9,
	0x50, 0x74, 0x55, 0x1D, 0x49, 0x04, 0x5A, 0x1C, 0xD6, 0x86, 0x68, 0x7C, 0xB6, 0x61, 0x48, 0x6C,
	0x96, 0xE6, 0x12, 0x4C, 0x27, 0xAD, 0xBA, 0xC7, 0x51, 0x99, 0x8E, 0xD0, 0xF0, 0xED, 0x8E, 0xF6,
	0x65, 0x79, 0x79, 0xA6, 0x12, 0xA1, 0x95, 0xDB, 0xC8, 0xAE, 0xE3, 0xB6, 0x35, 0xE6, 0x8D, 0xBC,
	0x48, 0xA3, 0x7F, 0xAF, 0x4A, 0x28, 0x8A, 0x53, 0xE2, 0x7E, 0x68, 0x08, 0x9F, 0x67, 0x77, 0x98,
	0x52, 0xDB, 0x50, 0x84, 0xD6, 0x5E, 0x25, 0xE1, 0x4A, 0x99, 0x58, 0x34, 0xC7, 0x11, 0xD6, 0x43,
	0xFF, 0xC4, 0xFD, 0x9A, 0x44, 0x16, 0xD1, 0xB2, 0xFB, 0x02, 0xDB, 0xA1, 0x89, 0x69, 0x34, 0xC2,
	0x32, 0x55, 0x98, 0xF9, 0x9B, 0xB2, 0x31, 0x3F, 0x49, 0x59, 0x0C, 0x06, 0x8C, 0xDB, 0xA5, 0xB2,
	0x9D, 0x7E, 0x12, 0x2F, 0xD0, 0x87, 0x94, 0x44, 0xE4, 0x0A, 0x76, 0xEF, 0x99, 0x2D, 0x91, 0x18,
	0x39, 0x50, 0x3B, 0x29, 0x3B, 0xF5, 0x2C, 0x97, 0x73, 0x48, 0x91, 0x83, 0xB0, 0xA6, 0xF3, 0x4B,
	0x70, 0x2F, 0x1C, 0x8F, 0x3B, 0x78, 0x23, 0xC6, 0xAA, 0x86, 0x46, 0x43, 0x1D, 0xD7, 0x2A, 0x23,
	0x5E, 0x2C, 0xD9, 0x48, 0x0A, 0xF5, 0xF5, 0x2C, 0xD1, 0xFB, 0x3F, 0xF0, 0x4B, 0x78, 0x37, 0xE9,
	0x45, 0xDD, 0x72, 0xCF, 0x80, 0x35, 0xC3, 0x95, 0x07, 0xF3, 0xD9, 0x06, 0xE5, 0x4A, 0x58, 0x76,
	0x03, 0x6C, 0x81, 0x20, 0x62, 0x45, 0x65, 0x44, 0x73, 0xBC, 0xFE, 0xC1, 0x9F, 0x31, 0xE5, 0xDB,
	0x89, 0x5C, 0x6B, 0x79, 0xD8, 0x68, 0x90, 0xD7, 0x26, 0xA8, 0xA1, 0x88, 0x86, 0x81, 0xDC, 0x9A,
	0x4F, 0x40, 0xA5, 0x23, 0xC7, 0xDE, 0xBE, 0x6F, 0x76, 0xAB, 0x79, 0x16, 0x51, 0x21, 0x67, 0x83,
	0x2E, 0xF3, 0xD6, 0x27, 0x1A, 0x42, 0xC2, 0x94, 0xD1, 0x5D, 0x6C, 0xDB, 0x4A, 0x7A, 0xE2, 0xCB,
	0x0B, 0xB0, 0x68, 0x0B, 0xBE, 0x19, 0x59, 0x00, 0x50, 0xFC, 0xC0, 0xBD, 0x9D, 0xF5, 0xF5, 0xF8,
	0xA8, 0x17, 0x19, 0xD6, 0xB3, 0xE9, 0x74, 0xBA, 0x50, 0xE5, 0x2C, 0x45, 0x7B, 0xF9, 0x93, 0xEA,
	0x5A, 0xF9, 0xA9, 0x30, 0xB1, 0x6F, 0x5B, 0x36, 0x24, 0x1E, 0x8D, 0x55, 0x57, 0xF4, 0xCC, 0x67,
	0xB2, 0x65, 0x6A, 0xA9, 0x36, 0x26, 0xD0, 0x06, 0xB8, 0xE2, 0xE3, 0x73, 0x8B, 0xD1, 0xC0, 0x1C,
	0x52, 0x15, 0xCA, 0xB5, 0xAC, 0x60, 0x3E, 0x36, 0x42, 0xF1, 0x2C, 0xBD, 0x99, 0x77, 0xAB, 0xA8,
	0xA9, 0xA4, 0x8E, 0x9C, 0x8B, 0x84, 0xDE, 0x73, 0xF0, 0x91, 0x29, 0x97, 0xAE, 0xDB, 0xAF, 0xD6,
	0xF8, 0x5E, 0x9B, 0x86, 0xB3, 0xB3, 0x03, 0xB3, 0xAC, 0x75, 0x6F, 0xA6, 0x11, 0x69, 0x2F, 0x3D,
	0x3A, 0xCE, 0xFA, 0x53, 0x86, 0x60, 0x95, 0x6C, 0xBB, 0xC5, 0x4E, 0xF3,
};

*/

}

#endif